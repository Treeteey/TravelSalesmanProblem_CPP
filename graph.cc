/*
Случайным образом задаются сто точек точки внутри окружности. 
Соединить их таким образом, чтобы каждая точка была соединена
как минимум с двумя соседними, как максимум - с шестью.

Теперь представим, что мы путешествуем из первой точки в какую-то
(задаётся пользователем). Но мы хотим посетить все точки и потратить
как можно меньше денег. Скажем, единица расстояния будет стоить 10 USD. 
Найти путь, который будет стоить минимум (или близкое к нему количество) денег.

В качестве результата хотелось бы видеть граф, построенный из точек. 
Стоимости переходов. Найденный путь. 
Будет плюсом, если сможете доказать правильность решения
*/

#include "header.h"



void Point::print(){
    std::cout << "(" << std::setw(7) << std::setprecision(2) << std::fixed << x_ 
                << ", " << std::setw(7) << std::setprecision(2)<< y_ << ")";
    std::cout << "  (";
    for(auto neighbor : neighbours_){
        std::cout << std::setw(2) << neighbor << " ";
    }
    std::cout << ")" << std::endl;
}


// ===================== GRAPH =====================

Graph::Graph(){
    number_ = 100;
    radius_ = 380;
    price_ = 10;
    ClearDistances();  
    CreatePoints();
    FillDistances();
    CreateNeighbours(2, 6);
    
};


Graph::Graph(int number, double radius, double price){
    number_ = number;
    radius_ = radius;            
    price_ = price;
    ClearDistances();  
    CreatePoints();
    FillDistances();
    CreateNeighbours(2, 6);             
}


void Graph::PrintGraph(){
    for(int i = 0; i < number_; ++i){
        std::cout << std::setw(3) << i << " ";
        points_[i].print();
    }
}


/**
 * \brief Generates a random integer within the given range [min, max]
 *
 * \param[in] min lower bound of the range
 * \param[in] max upper bound of the range
 * \return random integer within the range
 */
int RandomInt(int min, int max){
    static std::default_random_engine e;
    static std::uniform_int_distribution<> dis(min, max);
    return dis(e);
}





/**
 * \brief Creates a specified number of points within a circle of given radius
 *
 * \param[in] radius the radius of the circle
 * \param[in] count the number of points to create
 *
 * \details
 * This function generates a specified number of points within a circle of given radius.
 * The points are generated by randomly picking a point within the circle and checking
 * if the distance from the origin to the point is less than or equal to the radius.
 * If the point is within the circle, it is added to the list of points.
 */
void Graph::CreatePoints(){
    int temp = 0;    
    std::random_device rd;
    std::mt19937 e(rd());
    std::uniform_real_distribution<> dis(-radius_, radius_);
    while (temp < number_) {
        double x = dis(e);
        double y = dis(e);
        // Recheck to ensure the point is within the circle
        if ((radius_ * radius_) >= (x * x + y * y)) {
            points_.push_back(Point(x, y));
            temp+=1;
        }
    }
}

double Graph::Distance(const Point& a, const Point& b){
    return sqrt((a.x_ - b.x_) * (a.x_ - b.x_) + (a.y_ - b.y_) * (a.y_ - b.y_));
}

/**
 * \brief Generates a specified number of edges between points in the graph
 *
 * \param[in] min_neighbors the minimum number of neighbors for each point
 * \param[in] max_neighbors the maximum number of neighbors for each point
 *
 * \details
 * This function generates a specified number of edges between points in the graph.
 * For each point, it generates a random number of neighbors between min_neighbors
 * and max_neighbors. The points are selected randomly from the list of points.
 * If the point is already a neighbor of the current point, it is skipped.
 * The edges are added symmetrically, meaning that if point A is a neighbor of
 * point B, then point B is also a neighbor of point A.
 */
void Graph::CreateNeighbours(int min_neighbors, int max_neighbors) {
    std::random_device rd;
    std::mt19937 e(rd());
    std::uniform_int_distribution<> dis(0, points_.size() - 1);
    std::uniform_int_distribution<> dis_int(min_neighbors, max_neighbors);

    for (int i = 0; i < points_.size(); ++i) {
        // Случайное число соседей для текущей точки
        int rand_number_neighbors = dis_int(e);
        // Вектор пар (индекс, расстояние) по увеличению расстояний
        std::vector<std::pair<int, double>> temp;
        for (int j = 0; j < points_.size(); ++j) {
            temp.push_back(std::make_pair(j, distances_[i][j]));
        }
        std::sort(temp.begin(), temp.end(), [](const auto& a, const auto& b) {
            return a.second < b.second;
        });
        int counter = 0;
        while (points_[i].neighbours_.size() < rand_number_neighbors) {
            int index = temp[counter].first;
            if (i != index // Исключаем саму точку
                && points_[index].neighbours_.size() < max_neighbors
                && std::find(points_[i].neighbours_.begin(),points_[i].neighbours_.end(), index) == points_[i].neighbours_.end()) { // Проверяем, что индекс ещё не добавлен
                // Добавляем связь симметрично
                points_[i].neighbours_.push_back(index);
                points_[index].neighbours_.push_back(i);;
            }
            counter++;
        }
    }
}



/**
 * \brief Fills the distances_ matrix with the actual distances between neighbors
 *
 * \details
 * This function iterates over all points in the graph and for each point, it
 * iterates over all its neighbors. For each neighbor, it calculates the
 * distance between the two points and stores it in the distances_ matrix.
 * The distances_ matrix is symmetric, meaning that distances_[i][j] ==
 * distances_[j][i] for all i and j.
 */
void Graph::FillDistances(){
    for(int i = 0; i < number_; i++){
        for(int j = 0; j < number_; j++){
            distances_[i][j] = Distance(points_[i], points_[j]);
        }
        distances_[i][i] = -1.0;
    }
}

void Graph::WriteDistancesToFile() {
    std::ofstream file("distances.txt");
    if (!file.is_open()) {
        std::cerr << "Error opening file for writing." << std::endl;
        return;
    }

    for (int i = 0; i < number_; i++) {
        for (int j = 0; j < number_; j++) {
            file << std::setw(8) << distances_[i][j] << " ";
            if(j % 10 == 9) 
                file << " [" << j+1 << "] ";
        }
        file << std::endl;
    }

    file.close();
}




/**
 * \brief Resets the distances matrix for the graph
 *
 * \details
 * This function resizes the distances_ matrix to match the number of points
 * in the graph, and initializes all distances to zero. It prepares the matrix
 * to be filled with actual distances between points by other methods.
 */
void Graph::ClearDistances(){
    distances_.resize(number_, std::vector<double>(number_));
    for(int i = 0; i < number_; i++){
        for(int j = 0; j < number_; j++){
            distances_[i][j] = 0;
        }
    }
}




