/*
Случайным образом задаются сто точек точки внутри окружности. 
Соединить их таким образом, чтобы каждая точка была соединена
как минимум с двумя соседними, как максимум - с шестью.

Теперь представим, что мы путешествуем из первой точки в какую-то
(задаётся пользователем). Но мы хотим посетить все точки и потратить
как можно меньше денег. Скажем, единица расстояния будет стоить 10 USD. 
Найти путь, который будет стоить минимум (или близкое к нему количество) денег.

В качестве результата хотелось бы видеть граф, построенный из точек. 
Стоимости переходов. Найденный путь. 
Будет плюсом, если сможете доказать правильность решения
*/

#include "header.h"


/**
 * \brief Generates a random integer within the given range [min, max]
 *
 * \param[in] min lower bound of the range
 * \param[in] max upper bound of the range
 * \return random integer within the range
 */
int RandomInt(int min, int max){
    static std::default_random_engine e;
    static std::uniform_int_distribution<> dis(min, max);
    return dis(e);
}


void Point::print(){
    std::cout << "(" << std::setw(7) << std::setprecision(2) << std::fixed << x_ 
                << ", " << std::setw(7) << std::setprecision(2)<< y_ << ")";
    std::cout << "  (";
    for(auto neighbor : neighbours_){
        std::cout << std::setw(2) << neighbor << " ";
    }
    std::cout << ")" << std::endl;
}


/**
 * \brief Creates a specified number of points within a circle of given radius
 *
 * \param[in] radius the radius of the circle
 * \param[in] count the number of points to create
 *
 * \details
 * This function generates a specified number of points within a circle of given radius.
 * The points are generated by randomly picking a point within the circle and checking
 * if the distance from the origin to the point is less than or equal to the radius.
 * If the point is within the circle, it is added to the list of points.
 */
void Graph::CreatePoints(double radius, int count){
    int temp = count;    

    while (temp > 0) {
        std::random_device rd;
        std::mt19937 e(rd());
        std::uniform_real_distribution<> dis(-radius_, radius_);

        double x = dis(e);
        double y = dis(e);
        double distance = x * x + y * y;
        double rad_sqr = radius * radius;

        // Optional: Recheck to ensure the point is within the circle
        if (distance <= rad_sqr) {
            points_.push_back(Point(x, y));
            temp--;
        }
    }
}

double Graph::Distance(const Point& a, const Point& b){
    return sqrt((a.x_ - b.x_) * (a.x_ - b.x_) + (a.y_ - b.y_) * (a.y_ - b.y_));
}

/**
 * \brief Generates a specified number of edges between points in the graph
 *
 * \param[in] min_neighbors the minimum number of neighbors for each point
 * \param[in] max_neighbors the maximum number of neighbors for each point
 *
 * \details
 * This function generates a specified number of edges between points in the graph.
 * For each point, it generates a random number of neighbors between min_neighbors
 * and max_neighbors. The points are selected randomly from the list of points.
 * If the point is already a neighbor of the current point, it is skipped.
 * The edges are added symmetrically, meaning that if point A is a neighbor of
 * point B, then point B is also a neighbor of point A.
 */
void Graph::CreateNeighbours(int min_neighbors, int max_neighbors) {
    std::random_device rd;
    std::mt19937 e(rd());
    std::uniform_int_distribution<> dis(0, points_.size() - 1);
    std::uniform_int_distribution<> dis_int(min_neighbors, max_neighbors);

    for (int i = 0; i < points_.size(); ++i) {
        // Случайное число соседей для текущей точки
        int rand_number_neighbors = dis_int(e);

        while (points_[i].neighbours_.size() < rand_number_neighbors) {
            int index = dis(e);
            if (i != index // Исключаем саму точку
                && points_[index].neighbours_.size() < max_neighbors
                && std::find(points_[i].neighbours_.begin(),points_[i].neighbours_.end(), index) == points_[i].neighbours_.end()) { // Проверяем, что индекс ещё не добавлен
                // Добавляем связь симметрично
                points_[i].neighbours_.push_back(index);
                points_[index].neighbours_.push_back(i);;
            }
        }
    }
}



/**
 * \brief Fills the distances_ matrix with the actual distances between neighbors
 *
 * \details
 * This function iterates over all points in the graph and for each point, it
 * iterates over all its neighbors. For each neighbor, it calculates the
 * distance between the two points and stores it in the distances_ matrix.
 * The distances_ matrix is symmetric, meaning that distances_[i][j] ==
 * distances_[j][i] for all i and j.
 */
void Graph::FillDistances(){
    for(int i = 0; i < number_; i++){
        for(int neighbour : points_[i].neighbours_){
            distances_[i][neighbour] = Distance(points_[i], points_[neighbour]);
        }
    }
}

void Graph::PrintDistances(){
    for(int i = 0; i < number_; i++){
        for(int j = 0; j < number_; j++){
            std::cout << std::setw(10) << distances_[i][j] << " "; 
        }
        std::cout << std::endl;
    }
}


/**
 * \brief Resets the distances matrix for the graph
 *
 * \details
 * This function resizes the distances_ matrix to match the number of points
 * in the graph, and initializes all distances to zero. It prepares the matrix
 * to be filled with actual distances between points by other methods.
 */
void Graph::ClearDistances(){
    distances_.resize(number_, std::vector<double>(number_));
    for(int i = 0; i < number_; i++){
        for(int j = 0; j < number_; j++){
            distances_[i][j] = 0;
        }
    }
}


void Graph::PrintGraph(){
    for(int i = 0; i < number_; ++i){
        std::cout << std::setw(3) << i << " ";
        points_[i].print();
    }
}


Graph::Graph(){
    number_ = 100;
    radius_ = 1;
    price_ = 10;
    ClearDistances();  
    CreatePoints(radius_, number_);
    CreateNeighbours(2, 6);
    FillDistances();
};


Graph::Graph(int number, double radius, double price){
    number_ = number;
    radius_ = radius;            
    price_ = price;
    ClearDistances();  
    CreatePoints(radius_, number_);
    CreateNeighbours(2, 6);                 
    FillDistances();
}